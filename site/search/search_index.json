{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home My Daily Advanced JavaScript Study Notes Select the notes from the top Navigation Contents Compilers Types Closures Prototypes OOP in Javascript","title":"Home"},{"location":"#home","text":"My Daily Advanced JavaScript Study Notes","title":"Home"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/","text":"JS Engine What do we know/heard about JS Engine? Most cases, it uses V8 Engine internally It is single threaded and use call-back It is an interpreted language Let's talk about what this engine, we are mentioning. If I give a plain JS file to a Computer, It can not read or interpret the language. The CPU only understands the 0's and 1's. To fill this communication gap, we need a translator or interpreter. This is the position the V8 Engine come to play. This magical engine read our code and interpret it to the CPU. ECMA-Script Engine First JS Engine Firefox still using spider monkey Before 2008, most browser use very basic engines. When V8 came up, it was a significant pivotal time of JS. V8 was released by Google. While they were developing the Map application, it requires a powerful engine compare to traditional available JS engine. Inside V8 Engine Most popular Most usages Blazing Fast Used by Chrome Node.js Written in C++ It took the code and do the followings Lexical Analysis Parser (Do the tokenizations) AST (aka, Abstract Syntax Tree From token, it forms the tree) Interpreter (Translate the code to ByCode ) Profiler (Watcher for the Interpreter and looking for Optimization ) Compiler (If Profiler point out for some Optimization Required in the Interpreter it ) Optimization Interpreter Translate and read the code line by line Interpreting code means Take a set of instructions Return answer by doing according to the instructions In this case translation is happening on the fly Compiler It does not translate on the fly It works ahead of time Went through the whole code base Convert in a such way, the machine can understand the code Example Babel (Take modern JS and make them compatible to Old browser) Typescript (Superset of JS, compile down to JS) Interpreter Vs Compiler Interpreter Quick to get up and running Slower for repeated code Compiler Took little more time to start up compare to the Interpreter Can use some optimization mechanism for repeated codebase JIT Compiler Stands for Just In Time compiler. Both the interpreter and compiler has its pro and cons. Some engineers from google came up with the goodies of them and created the JIT Compiler V8 and JIT Compiler In V8 , the code is translated to Byte Code by Interpreter . The V8 is intelligent enough to determine if there is an optimization is required. In this case the V8 engine brings the JIT Compiler . Is Javascript interpreted language? It depends on the implementation. Initially JS was the interpreted language. Now with V8 it's the Compiled language. Same goes for the Python . It could be both, interpreted or compiled.","title":"01 JS Engine"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#js-engine","text":"","title":"JS Engine"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#what-do-we-knowheard-about-js-engine","text":"Most cases, it uses V8 Engine internally It is single threaded and use call-back It is an interpreted language Let's talk about what this engine, we are mentioning. If I give a plain JS file to a Computer, It can not read or interpret the language. The CPU only understands the 0's and 1's. To fill this communication gap, we need a translator or interpreter. This is the position the V8 Engine come to play. This magical engine read our code and interpret it to the CPU.","title":"What do we know/heard about JS Engine?"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#ecma-script-engine","text":"First JS Engine Firefox still using spider monkey Before 2008, most browser use very basic engines. When V8 came up, it was a significant pivotal time of JS. V8 was released by Google. While they were developing the Map application, it requires a powerful engine compare to traditional available JS engine.","title":"ECMA-Script Engine"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#inside-v8-engine","text":"Most popular Most usages Blazing Fast Used by Chrome Node.js Written in C++ It took the code and do the followings Lexical Analysis Parser (Do the tokenizations) AST (aka, Abstract Syntax Tree From token, it forms the tree) Interpreter (Translate the code to ByCode ) Profiler (Watcher for the Interpreter and looking for Optimization ) Compiler (If Profiler point out for some Optimization Required in the Interpreter it ) Optimization","title":"Inside V8 Engine"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#interpreter","text":"Translate and read the code line by line Interpreting code means Take a set of instructions Return answer by doing according to the instructions In this case translation is happening on the fly","title":"Interpreter"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#compiler","text":"It does not translate on the fly It works ahead of time Went through the whole code base Convert in a such way, the machine can understand the code Example Babel (Take modern JS and make them compatible to Old browser) Typescript (Superset of JS, compile down to JS)","title":"Compiler"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#interpreter-vs-compiler","text":"Interpreter Quick to get up and running Slower for repeated code Compiler Took little more time to start up compare to the Interpreter Can use some optimization mechanism for repeated codebase","title":"Interpreter Vs Compiler"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#jit-compiler","text":"Stands for Just In Time compiler. Both the interpreter and compiler has its pro and cons. Some engineers from google came up with the goodies of them and created the JIT Compiler","title":"JIT Compiler"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#v8-and-jit-compiler","text":"In V8 , the code is translated to Byte Code by Interpreter . The V8 is intelligent enough to determine if there is an optimization is required. In this case the V8 engine brings the JIT Compiler .","title":"V8 and JIT Compiler"},{"location":"Notes/01 Javascript Foundation/01 JS Engine/#is-javascript-interpreted-language","text":"It depends on the implementation. Initially JS was the interpreted language. Now with V8 it's the Compiled language. Same goes for the Python . It could be both, interpreted or compiled.","title":"Is Javascript interpreted language?"},{"location":"Notes/01 Javascript Foundation/02 Writing Optimized Code/","text":"Writing Optimized Code Wring optimized code means helping the compiler and not to go against it. Couple of methods and property to look out. eval() arguments for in with delete Here we will briefly discuss on Inline Caching Hidden Classes Inline Caching Let's we have a method findUser , that take a user as parameter and returns a Template Literal along with the user first name and last name. findUser(user) { return `found user ${user.firstName} ${user.lastName}`; } const userData = { firstName: 'Shams', lastName: 'Nahid' } findUser(userData); If we call the method findUser over and over again, the compiler will cache the method as a string of followings found user Shams Nahid Hidden Classes Let's say we have a class with a constructor, having two property, x and y . If we have 2 objects based on that class it's okay and optimized. But as long as we start to assign new properties, compiler gets confused and assume there is no common hidden class. function MyMethod(x, y) { this.x = x; this.y = y; } const obj1 = new MyMethod(1, 2); const obj2 = new MyMethod(3, 4); Here by the compiler both objects ob1 and ob2 are considered to share the same hidden class. But as soon as we add individual property with the objects, ob1.a = 10; ob2.b = 25; It makes the compiler slower. In this case the compiler assume that these objects does not share same hidden classes. Delete Same as hidden class , if we delete a object property using the delete operator like, delete ob1.x; The compiler assume the object does not sharing the same hidden class.","title":"02 Writing Optimized Code"},{"location":"Notes/01 Javascript Foundation/02 Writing Optimized Code/#writing-optimized-code","text":"Wring optimized code means helping the compiler and not to go against it. Couple of methods and property to look out. eval() arguments for in with delete Here we will briefly discuss on Inline Caching Hidden Classes","title":"Writing Optimized Code"},{"location":"Notes/01 Javascript Foundation/02 Writing Optimized Code/#inline-caching","text":"Let's we have a method findUser , that take a user as parameter and returns a Template Literal along with the user first name and last name. findUser(user) { return `found user ${user.firstName} ${user.lastName}`; } const userData = { firstName: 'Shams', lastName: 'Nahid' } findUser(userData); If we call the method findUser over and over again, the compiler will cache the method as a string of followings found user Shams Nahid","title":"Inline Caching"},{"location":"Notes/01 Javascript Foundation/02 Writing Optimized Code/#hidden-classes","text":"Let's say we have a class with a constructor, having two property, x and y . If we have 2 objects based on that class it's okay and optimized. But as long as we start to assign new properties, compiler gets confused and assume there is no common hidden class. function MyMethod(x, y) { this.x = x; this.y = y; } const obj1 = new MyMethod(1, 2); const obj2 = new MyMethod(3, 4); Here by the compiler both objects ob1 and ob2 are considered to share the same hidden class. But as soon as we add individual property with the objects, ob1.a = 10; ob2.b = 25; It makes the compiler slower. In this case the compiler assume that these objects does not share same hidden classes.","title":"Hidden Classes"},{"location":"Notes/01 Javascript Foundation/02 Writing Optimized Code/#delete","text":"Same as hidden class , if we delete a object property using the delete operator like, delete ob1.x; The compiler assume the object does not sharing the same hidden class.","title":"Delete"},{"location":"Notes/01 Javascript Foundation/03 Call Stack and Memory Heap/","text":"Call Stack and Memory Heap Call Stack Keep track where we are on track Memory Heap Place to allocate memory Use to store and write operation","title":"03 Call Stack and Memory Heap"},{"location":"Notes/01 Javascript Foundation/03 Call Stack and Memory Heap/#call-stack-and-memory-heap","text":"","title":"Call Stack and Memory Heap"},{"location":"Notes/01 Javascript Foundation/03 Call Stack and Memory Heap/#call-stack","text":"Keep track where we are on track","title":"Call Stack"},{"location":"Notes/01 Javascript Foundation/03 Call Stack and Memory Heap/#memory-heap","text":"Place to allocate memory Use to store and write operation","title":"Memory Heap"},{"location":"Notes/01 Javascript Foundation/04 Memory Leak/","text":"Memory Leak To avoid memory leak, we can consider the followings Use less number of global variables While adding a listener, ensuring removing the listener Carefully using the setInterval method. The code snippet, call stack and memory heap of the setInterval is not cleared by the Garbage Collection","title":"04 Memory Leak"},{"location":"Notes/01 Javascript Foundation/04 Memory Leak/#memory-leak","text":"To avoid memory leak, we can consider the followings Use less number of global variables While adding a listener, ensuring removing the listener Carefully using the setInterval method. The code snippet, call stack and memory heap of the setInterval is not cleared by the Garbage Collection","title":"Memory Leak"},{"location":"Notes/01 Javascript Foundation/05 Single Threaded/","text":"Single Threaded Javascript is single threaded language Being single threaded means, only one set of instructions being executed at once Checking a language is single threaded means, it should have only one call stack This single threaded nature makes the Javascript synchronous","title":"05 Single Threaded"},{"location":"Notes/01 Javascript Foundation/05 Single Threaded/#single-threaded","text":"Javascript is single threaded language Being single threaded means, only one set of instructions being executed at once Checking a language is single threaded means, it should have only one call stack This single threaded nature makes the Javascript synchronous","title":"Single Threaded"},{"location":"Notes/01 Javascript Foundation/06 Javascript Runtime/","text":"Javascript Runtime Javascript is a single threaded language hence has one call stack and one memory heap. So as single thread architecture, one program should wait to complete the previous program. For a long running process, the program will be too much slow. That should not be an ideal case. This is where the Javascript runtime comes in. In browser, the web api works as a javascript runtime. This web api is available in all the major browsers, like chrome, edge, opera, firefox etc. This handle the long running process and let the call stack know it is done with some process and data is ready. This web api handle the fetch api, dom events, long running process like set-timeout or set-interval method. Even this web api can be used as caching or runtime database. So when a long running async process came up in the call stack, it pass that task to the web-api. Web-api handle the task in background and put the completed task to the call-back-queue. The event loop always check if the call stack is empty or not. If it is empty then it put the completed task from the call-back-queue to call-stack. How come we use web api to handle stack overflow. (Calling a method more than stack size, with explanation) (section 24) How come promise comes before setTimeOut 0, section 25","title":"06 Javascript Runtime"},{"location":"Notes/01 Javascript Foundation/06 Javascript Runtime/#javascript-runtime","text":"Javascript is a single threaded language hence has one call stack and one memory heap. So as single thread architecture, one program should wait to complete the previous program. For a long running process, the program will be too much slow. That should not be an ideal case. This is where the Javascript runtime comes in. In browser, the web api works as a javascript runtime. This web api is available in all the major browsers, like chrome, edge, opera, firefox etc. This handle the long running process and let the call stack know it is done with some process and data is ready. This web api handle the fetch api, dom events, long running process like set-timeout or set-interval method. Even this web api can be used as caching or runtime database. So when a long running async process came up in the call stack, it pass that task to the web-api. Web-api handle the task in background and put the completed task to the call-back-queue. The event loop always check if the call stack is empty or not. If it is empty then it put the completed task from the call-back-queue to call-stack. How come we use web api to handle stack overflow. (Calling a method more than stack size, with explanation) (section 24) How come promise comes before setTimeOut 0, section 25","title":"Javascript Runtime"},{"location":"Notes/01 Javascript Foundation/07 Execution Context/","text":"Execution Context We run code by Defining objects Invoking methods Every time we invoke a method, the Javascript engine creates a new execution context. Global Execution Context Even though we do not define any objects or methods, the Javascript created a Global Execution Context . This global execution context provides a global object named window . In node.js world this global object is called global . Global execution also provide the this context. Both, the this context and window object are the same object. Also there are Hosting in the global execution section, used to run before the code execution. Whenever we define a global object, it is attached to the window object by the global context .","title":"07 Execution Context"},{"location":"Notes/01 Javascript Foundation/07 Execution Context/#execution-context","text":"We run code by Defining objects Invoking methods Every time we invoke a method, the Javascript engine creates a new execution context.","title":"Execution Context"},{"location":"Notes/01 Javascript Foundation/07 Execution Context/#global-execution-context","text":"Even though we do not define any objects or methods, the Javascript created a Global Execution Context . This global execution context provides a global object named window . In node.js world this global object is called global . Global execution also provide the this context. Both, the this context and window object are the same object. Also there are Hosting in the global execution section, used to run before the code execution. Whenever we define a global object, it is attached to the window object by the global context .","title":"Global Execution Context"},{"location":"Notes/01 Javascript Foundation/08 Lexical Environment/","text":"Lexical Environment Lexical environment is a place where we write code Every time we create an execution context, code inside these contexts are under a lexical environment When we do the lexical analysis , it find the work or token location or which context it belongs to We can consider lexical environment as a planet for execution context Lexical environment determine the access of the methods and objects The first lexical environment is the global execution context","title":"08 Lexical Environment"},{"location":"Notes/01 Javascript Foundation/08 Lexical Environment/#lexical-environment","text":"Lexical environment is a place where we write code Every time we create an execution context, code inside these contexts are under a lexical environment When we do the lexical analysis , it find the work or token location or which context it belongs to We can consider lexical environment as a planet for execution context Lexical environment determine the access of the methods and objects The first lexical environment is the global execution context","title":"Lexical Environment"},{"location":"Notes/01 Javascript Foundation/09 Hoisting/","text":"Hoisting This hoisting feature is resided in the Global Execution Context Before run the code, this feature hoist the var and function For var keyword, it allocate a memory in the memory heap with value undefined (Partial Hoisting) For function , it hoisted the whole functional definition This hoisting feature is applicable for only var keyword Function Declaration Functional Expression with var keyword Does not applicable for let or const keyword Example 01: console.log(myVar); var myVar = 'Hello World!'; Here the hosting feature assume there will be a variable named myVar and assigned initial value undefined . So this Will return undefined . Example 02: console.log(myMethod()); function myMethod() { return 'Hello World!!!'; } Since hoisting feature hoist the function with its definition, this will return Hello World!!! . Example 03: console.log(myMethod()); (function myMethod() { return 'Hello World!!!'; }); In this case, the hoisting does not find any function keyword, instead it get the ( . So this Will throw Reference Error . Example 04: console.log(myMethod); (function myMethod() { return 'Hello World!!!'; }); Like previous explanation, the hoisting does not get any function, instead it saws the ( . So this will throw Reference Error . Example 05: console.log(myValue); const myValue = 'Hello World'; Since ES6 feature, let and const does not support the hoisting, this will throw Reference Error . Example 06: console.log(myValue); let myValue = 'Hello World'; Like previous example, since ES6 feature, let and const does not support the hoisting, this will throw Reference Error . Example 07: console.log(myMethod()); var myMethod = function () { return 'Hello World!!!'; }; Here the hoisting feature hoist the myMethod with value undefined . In console.log it is interpreted something like undefined() . So this will throw Reference Error . Example 08: console.log(myMethod); var myMethod = function () { return 'Hello World!!!'; }; In this case, the hoist feature hoist the myMethod and in memory heap, assigned the initial value undefined . So this Will return undefined . Example 09: console.log(myValue); var myValue = 1; var myValue = 2; Hoisting do partial hoisting for the var keyword. In this case, when the hoisting first get the newValue declaration it put the initial value, undefined . When it again encounter the myValue it just ignore the definition. And it will return undefined . Example 10: console.log(myMethod()); function myMethod() { return 'Initial Encounter'; } function myMethod() { return 'Final Encounter'; } In this case, when the first time myMethod will be encountered, it will hoist the definition which is returning Initial Encounter . When the hoisting feature again encounter myMethod , it will again hoist the new definition that is returning Final Encounter . So this will return Final Encounter . Example 11: var myValue = 'Hello World!!'; var myMethod = function () { console.log(`My Value: ${myValue}`); var myValue = 'Updated Value'; console.log(`My Value: ${myValue}`); }; myMethod(); According to the object hoisting, it happens every time a new execution context is being created. Also, every time we invoke a method, a new execution context is being created. For the global execution context, the hoisting set myValue and myMethod as undefined . Now for the myMethod a new execution context and a new hoisting is created. Here using the hoisting myValue is hoisted as undefined . This will return the following 2 lines My Value: undefined My Value: Updated Value Example 12: var myValue = 'Hello World!!'; var myMethod = function () { console.log(`My Value: ${myValue}`); var myNewValue = 'Updated Value'; console.log(`My Value: ${myNewValue}`); }; myMethod(); Comparing from the previous example, whenever there is not conflicting of method scoped variable and global hoisted variable, we should get the output as expected. This will return the following 2 lines My Value: Hello World!! My Value: Updated Value Avoiding Object Hoisting From the example 11 and 12, we see that the out put is not predicted due to the hoisting. To make the codebase predicted we can use const and let instead of var .","title":"09 Hoisting"},{"location":"Notes/01 Javascript Foundation/09 Hoisting/#hoisting","text":"This hoisting feature is resided in the Global Execution Context Before run the code, this feature hoist the var and function For var keyword, it allocate a memory in the memory heap with value undefined (Partial Hoisting) For function , it hoisted the whole functional definition This hoisting feature is applicable for only var keyword Function Declaration Functional Expression with var keyword Does not applicable for let or const keyword Example 01: console.log(myVar); var myVar = 'Hello World!'; Here the hosting feature assume there will be a variable named myVar and assigned initial value undefined . So this Will return undefined . Example 02: console.log(myMethod()); function myMethod() { return 'Hello World!!!'; } Since hoisting feature hoist the function with its definition, this will return Hello World!!! . Example 03: console.log(myMethod()); (function myMethod() { return 'Hello World!!!'; }); In this case, the hoisting does not find any function keyword, instead it get the ( . So this Will throw Reference Error . Example 04: console.log(myMethod); (function myMethod() { return 'Hello World!!!'; }); Like previous explanation, the hoisting does not get any function, instead it saws the ( . So this will throw Reference Error . Example 05: console.log(myValue); const myValue = 'Hello World'; Since ES6 feature, let and const does not support the hoisting, this will throw Reference Error . Example 06: console.log(myValue); let myValue = 'Hello World'; Like previous example, since ES6 feature, let and const does not support the hoisting, this will throw Reference Error . Example 07: console.log(myMethod()); var myMethod = function () { return 'Hello World!!!'; }; Here the hoisting feature hoist the myMethod with value undefined . In console.log it is interpreted something like undefined() . So this will throw Reference Error . Example 08: console.log(myMethod); var myMethod = function () { return 'Hello World!!!'; }; In this case, the hoist feature hoist the myMethod and in memory heap, assigned the initial value undefined . So this Will return undefined . Example 09: console.log(myValue); var myValue = 1; var myValue = 2; Hoisting do partial hoisting for the var keyword. In this case, when the hoisting first get the newValue declaration it put the initial value, undefined . When it again encounter the myValue it just ignore the definition. And it will return undefined . Example 10: console.log(myMethod()); function myMethod() { return 'Initial Encounter'; } function myMethod() { return 'Final Encounter'; } In this case, when the first time myMethod will be encountered, it will hoist the definition which is returning Initial Encounter . When the hoisting feature again encounter myMethod , it will again hoist the new definition that is returning Final Encounter . So this will return Final Encounter . Example 11: var myValue = 'Hello World!!'; var myMethod = function () { console.log(`My Value: ${myValue}`); var myValue = 'Updated Value'; console.log(`My Value: ${myValue}`); }; myMethod(); According to the object hoisting, it happens every time a new execution context is being created. Also, every time we invoke a method, a new execution context is being created. For the global execution context, the hoisting set myValue and myMethod as undefined . Now for the myMethod a new execution context and a new hoisting is created. Here using the hoisting myValue is hoisted as undefined . This will return the following 2 lines My Value: undefined My Value: Updated Value Example 12: var myValue = 'Hello World!!'; var myMethod = function () { console.log(`My Value: ${myValue}`); var myNewValue = 'Updated Value'; console.log(`My Value: ${myNewValue}`); }; myMethod(); Comparing from the previous example, whenever there is not conflicting of method scoped variable and global hoisted variable, we should get the output as expected. This will return the following 2 lines My Value: Hello World!! My Value: Updated Value","title":"Hoisting"},{"location":"Notes/01 Javascript Foundation/09 Hoisting/#avoiding-object-hoisting","text":"From the example 11 and 12, we see that the out put is not predicted due to the hoisting. To make the codebase predicted we can use const and let instead of var .","title":"Avoiding Object Hoisting"},{"location":"Notes/01 Javascript Foundation/10 Fucntion Invoking/","text":"Function Invoking We can define function in two ways, Function Expression var myMethod = function () { console.log('This is function expression'); }; Can be written in arrow syntax, var myMethod = () => console.log('This is function expression'); Function Declaration function() { console.log('This is function declaration'); } When we use the function declaration, it is hoisted. But the function expression does not get hoisted. arguments Javascript has a arguments in the function's execution context.","title":"10 Fucntion Invoking"},{"location":"Notes/01 Javascript Foundation/10 Fucntion Invoking/#function-invoking","text":"We can define function in two ways, Function Expression var myMethod = function () { console.log('This is function expression'); }; Can be written in arrow syntax, var myMethod = () => console.log('This is function expression'); Function Declaration function() { console.log('This is function declaration'); } When we use the function declaration, it is hoisted. But the function expression does not get hoisted.","title":"Function Invoking"},{"location":"Notes/01 Javascript Foundation/10 Fucntion Invoking/#arguments","text":"Javascript has a arguments in the function's execution context.","title":"arguments"},{"location":"Notes/01 Javascript Foundation/11 Scope Chain/","text":"Scope Chain When a function is being executed, in the execution context, there is a link of the parent environment. This link is called scope chain . So when a object/variable is not found in the functional scope, It goes to the parent environment using this scope chain . N.B. The global execution has the Global Lexical Environment [[scope]] This keyword return the parents scope of the method. function myMethod() {} In browser when we check window.myMethod properties, it will show its environment Global","title":"11 Scope Chain"},{"location":"Notes/01 Javascript Foundation/11 Scope Chain/#scope-chain","text":"When a function is being executed, in the execution context, there is a link of the parent environment. This link is called scope chain . So when a object/variable is not found in the functional scope, It goes to the parent environment using this scope chain .","title":"Scope Chain"},{"location":"Notes/01 Javascript Foundation/11 Scope Chain/#nb","text":"The global execution has the Global Lexical Environment","title":"N.B."},{"location":"Notes/01 Javascript Foundation/11 Scope Chain/#scope","text":"This keyword return the parents scope of the method. function myMethod() {} In browser when we check window.myMethod properties, it will show its environment Global","title":"[[scope]]"},{"location":"Notes/01 Javascript Foundation/12 Weird Syntax/","text":"Weird Syntax Example 1 Let's observe an example function myMethod() { myVal = 50; return myVal; } console.log(myMethod()); Here the myValue belongs to the global execution context. Without defining, this is an un-predicted behaviour. To restrict this type of un-predicted behaviour, we can use use strict on the top. Example 2 Now, let's see another syntax. var myMethod = function myMethodName() { return 'Hello World!!'; }; Here the myMethod belongs to the global lexical environment. But the myMethodName belongs to the functional lexical environment.","title":"12 Weird Syntax"},{"location":"Notes/01 Javascript Foundation/12 Weird Syntax/#weird-syntax","text":"","title":"Weird Syntax"},{"location":"Notes/01 Javascript Foundation/12 Weird Syntax/#example-1","text":"Let's observe an example function myMethod() { myVal = 50; return myVal; } console.log(myMethod()); Here the myValue belongs to the global execution context. Without defining, this is an un-predicted behaviour. To restrict this type of un-predicted behaviour, we can use use strict on the top.","title":"Example 1"},{"location":"Notes/01 Javascript Foundation/12 Weird Syntax/#example-2","text":"Now, let's see another syntax. var myMethod = function myMethodName() { return 'Hello World!!'; }; Here the myMethod belongs to the global lexical environment. But the myMethodName belongs to the functional lexical environment.","title":"Example 2"},{"location":"Notes/01 Javascript Foundation/13 Scope/","text":"Scope Example 1 Block scope does not work with Javascript when using the var keyword. if (true) { var myVal = 'Hello World!!'; } console.log(myVal); This will print the myVal , even though the myVal is inside the block scope. Example 2 Functional scope works with the var keyword. function myMethod() { var myVal = 'Hello World!!'; } console.log(myVal); Now the myVal is inside the functional scope. This is not accessible from the global lexical environment. Example 3 To use this block scope, instead of using var keyword, we can use const or let keyword. if (true) { const myVal = 'Hello World!!'; } console.log(myVal); if (true) { const myVal = 'Hello World!!'; } console.log(myVal); In the both example the JS engine will through the Reference Error .","title":"13 Scope"},{"location":"Notes/01 Javascript Foundation/13 Scope/#scope","text":"","title":"Scope"},{"location":"Notes/01 Javascript Foundation/13 Scope/#example-1","text":"Block scope does not work with Javascript when using the var keyword. if (true) { var myVal = 'Hello World!!'; } console.log(myVal); This will print the myVal , even though the myVal is inside the block scope.","title":"Example 1"},{"location":"Notes/01 Javascript Foundation/13 Scope/#example-2","text":"Functional scope works with the var keyword. function myMethod() { var myVal = 'Hello World!!'; } console.log(myVal); Now the myVal is inside the functional scope. This is not accessible from the global lexical environment.","title":"Example 2"},{"location":"Notes/01 Javascript Foundation/13 Scope/#example-3","text":"To use this block scope, instead of using var keyword, we can use const or let keyword. if (true) { const myVal = 'Hello World!!'; } console.log(myVal); if (true) { const myVal = 'Hello World!!'; } console.log(myVal); In the both example the JS engine will through the Reference Error .","title":"Example 3"},{"location":"Notes/01 Javascript Foundation/14 IIFE/","text":"IIFE Stands for Immediately Invoke Function Invocation Can be use to minimize global variable declaration IIFE has the following syntax (function () {})(); IIFE is a function expression, not a function declaration We can not call a function declaration function() {}() This will throw syntax error. But using IIFE we can call a function declaration immediately. (function () {})(); Benefits of IIFE No global property is created, all the properties is inside the function declaration scope. (function () { var a = 10; })(); a; Here a is defined inside the function expression, not available in the global scope. It creates it's own execution context, variable environment","title":"14 IIFE"},{"location":"Notes/01 Javascript Foundation/14 IIFE/#iife","text":"Stands for Immediately Invoke Function Invocation Can be use to minimize global variable declaration IIFE has the following syntax (function () {})(); IIFE is a function expression, not a function declaration We can not call a function declaration function() {}() This will throw syntax error. But using IIFE we can call a function declaration immediately. (function () {})();","title":"IIFE"},{"location":"Notes/01 Javascript Foundation/14 IIFE/#benefits-of-iife","text":"No global property is created, all the properties is inside the function declaration scope. (function () { var a = 10; })(); a; Here a is defined inside the function expression, not available in the global scope. It creates it's own execution context, variable environment","title":"Benefits of IIFE"},{"location":"Notes/01 Javascript Foundation/15 this/","text":"this this is the object, the function is property of obj.someFunc(this); Here obj is the this . Another example, const myObject = { name: 'foo', task: function () { return `This is ${this.name} task.`; } }; myObject.task(); This will return the text This is foo task. . By definition, here this refers to the object myObject . The function of task is the property of myObject . In global scope, this is the window object In global scope, if we define a function function a() { console.log(this); } It will print the window object. Since, the a() method is window.a() , so according to our first definition, for a() , this is the window object. When considering method, this means, who called the method Example const a = function () { console.log('For a, this is ', this); const b = function () { console.log('For b, this is ', this); const c = { hi: function () { console.log('For c, this is ', this); } }; c.hi(); }; }; a(); In this case, both a and b has the window object as this . And for c , since it is invoked by c , then, the this is the c object. Now, query might be, how b() has the this object window , not the a . Because b() is not invoked by in similar way a.b() . Instead, it is invoked like window.a(b()) this is not lexically scoped, it depends on how it is called (dynamically scoped). Example const obj = { name: 'Billy', sing() { console.log('a', this); var anotherMethod = function () { console.log('b', this); }; anotherMethod(); } }; obj.sing(); Here for a , the this context is obj . For b , the this context should be obj . But since, this is not lexically scoped and follow method calls, b has the this context of window . This is why this follows the dynamic scoped instead of lexical scoped . To solve this dynamic scope issue, we can use arrow method . Arrow method is bound to the lexical scoped . Example const obj = { name: 'Billy', sing() { console.log('a', this); var anotherMethod = () => { console.log('b', this); }; anotherMethod(); } }; obj.sing(); Here both a and b has the this context of obj . Another was to make the this to lexical scoped is using bind() method. Example const obj = { name: 'Billy', sing() { console.log('a', this); var anotherMethod = function () { console.log('b', this); }; return anotherMethod.bind(this); } }; obj.sing()(); Here also a and b has the this context of obj . This was the go to method before we using the arrow method . Another way to use the this context of the lexical scope is store the this context of the lexical scope . const obj = { name: 'Billy', sing() { console.log('a', this); var self = this; var anotherMethod = function () { console.log('b', self); }; anotherMethod(); } }; obj.sing(); Here both a and b have the this context of obj . Manipulating the this context We can manipulate the this keyword using the following methods call() Every time we invoke a method, call() method is being invoked internally. js var myMethod = function () {}; // following both statements are similar myMethod(); myMethod.call(); Let's took an method using the call method. ```js const wizard = { name: 'Wizard', health: 50, heal() { this.health = 100; } }; const archer = { name: 'Archer', health: 30 }; wizard.heal.call(archer); console.log(archer); ``` This will print bash { name: 'Archer', health: 100 } Here the health property is same as the wizard object. Now, let see another example of passing parameter using the call method. ```js const wizard = { name: 'Wizard', health: 50, heal(param1, param2) { this.health = this.health + param1 + param2; } }; const archer = { name: 'Archer', health: 30 }; wizard.heal.call(archer, 10, 20); console.log(archer); ``` This will add the params 10 and 20 with it existing value 30 . So the printed value be, bash { name: 'Archer', health: 60 } apply() apply() is similar to call() It uses call() underlying js var myMethod = function () {}; // following both statements are similar myMethod(); myMethod.apply(); The only difference between call() and apply() is, in apply() , the parameter is passed through the parenthesis. ```js const wizard = { name: 'Wizard', health: 50, heal(param1, param2) { this.health = this.health + param1 + param2; } }; const archer = { name: 'Archer', health: 30 }; wizard.heal.apply(archer, [10, 20]); console.log(archer); ``` This will print the same value as previous call() method. bash { name: 'Archer', health: 60 } bind() Except the call() and bind() , the bind() does not invoke the method instantly. Instead, it returns a method that can be invoked later. Example ```js const wizard = { name: 'Wizard', health: 50, heal(param1, param2) { this.health = this.health + param1 + param2; } }; const archer = { name: 'Archer', health: 30 }; const archerHeal = wizard.heal.bind(archer, 10, 20); archerHeal(); console.log(archer); ``` This will print the same value as previous call() or apply() method. bash { name: 'Archer', health: 60 } bind() and currying Let's we have a method that take two numbers and return the multiply result. js const multiplyMethod = (num1, num2) => { return num1 * num2; }; Now using function bind, we will create two method from the previous method. Both method will provide only one parameter. One will return multiply with 4 Another will return multiply with 10 ```js let multiplyByTwo = multiplyMethod.bind(this, 4); let multiplyByTen = multiplyMethod.bind(this, 10); console.log(multiplyByTwo(2)); console.log(multiplyByTen(2)); ``` This will return bash 8 20 Using this bind() curring, we can easily bind the method and use the flexibility. Benefits Allow methods and properties of object itself Example const myObject = { name: 'foo', task: function () { return `Do ${this.name} task.`; }, doTask: function () { return `Do ${this.task()}`; } }; myObject.doTask(); This will return Do foo task. Execute same code for multiple objects Example function showMyName() { console.log(this.name); } const foo = { name: 'foo', showMyName }; const bar = { name: 'foo', showMyName }; foo(); bar(); This will return foo bar Exercise Let's observe, couple of example Example 01 : const myObj = { name: 'myName', myMethod() { console.log(this); } }; myObj.myMethod(); Here the this is the myObj itself. Example 02 : const myObj = { name: 'myName', myMethod() { return function () { return console.log(this); }; } }; myObj.myMethod()(); Since the return function is not called by the myObj , here the this object is the window . It is using dynamic scope instead of lexical scope . Example 03 : const myObj = { name: 'myName', myMethod() { return () => { return console.log(this); }; } }; myObj.myMethod()(); Since, the arrow method strictly maintain the lexical scope , here the this represent the myObj .","title":"15 this"},{"location":"Notes/01 Javascript Foundation/15 this/#this","text":"this is the object, the function is property of obj.someFunc(this); Here obj is the this . Another example, const myObject = { name: 'foo', task: function () { return `This is ${this.name} task.`; } }; myObject.task(); This will return the text This is foo task. . By definition, here this refers to the object myObject . The function of task is the property of myObject . In global scope, this is the window object In global scope, if we define a function function a() { console.log(this); } It will print the window object. Since, the a() method is window.a() , so according to our first definition, for a() , this is the window object. When considering method, this means, who called the method Example const a = function () { console.log('For a, this is ', this); const b = function () { console.log('For b, this is ', this); const c = { hi: function () { console.log('For c, this is ', this); } }; c.hi(); }; }; a(); In this case, both a and b has the window object as this . And for c , since it is invoked by c , then, the this is the c object. Now, query might be, how b() has the this object window , not the a . Because b() is not invoked by in similar way a.b() . Instead, it is invoked like window.a(b()) this is not lexically scoped, it depends on how it is called (dynamically scoped). Example const obj = { name: 'Billy', sing() { console.log('a', this); var anotherMethod = function () { console.log('b', this); }; anotherMethod(); } }; obj.sing(); Here for a , the this context is obj . For b , the this context should be obj . But since, this is not lexically scoped and follow method calls, b has the this context of window . This is why this follows the dynamic scoped instead of lexical scoped . To solve this dynamic scope issue, we can use arrow method . Arrow method is bound to the lexical scoped . Example const obj = { name: 'Billy', sing() { console.log('a', this); var anotherMethod = () => { console.log('b', this); }; anotherMethod(); } }; obj.sing(); Here both a and b has the this context of obj . Another was to make the this to lexical scoped is using bind() method. Example const obj = { name: 'Billy', sing() { console.log('a', this); var anotherMethod = function () { console.log('b', this); }; return anotherMethod.bind(this); } }; obj.sing()(); Here also a and b has the this context of obj . This was the go to method before we using the arrow method . Another way to use the this context of the lexical scope is store the this context of the lexical scope . const obj = { name: 'Billy', sing() { console.log('a', this); var self = this; var anotherMethod = function () { console.log('b', self); }; anotherMethod(); } }; obj.sing(); Here both a and b have the this context of obj .","title":"this"},{"location":"Notes/01 Javascript Foundation/15 this/#manipulating-the-this-context","text":"We can manipulate the this keyword using the following methods call() Every time we invoke a method, call() method is being invoked internally. js var myMethod = function () {}; // following both statements are similar myMethod(); myMethod.call(); Let's took an method using the call method. ```js const wizard = { name: 'Wizard', health: 50, heal() { this.health = 100; } }; const archer = { name: 'Archer', health: 30 }; wizard.heal.call(archer); console.log(archer); ``` This will print bash { name: 'Archer', health: 100 } Here the health property is same as the wizard object. Now, let see another example of passing parameter using the call method. ```js const wizard = { name: 'Wizard', health: 50, heal(param1, param2) { this.health = this.health + param1 + param2; } }; const archer = { name: 'Archer', health: 30 }; wizard.heal.call(archer, 10, 20); console.log(archer); ``` This will add the params 10 and 20 with it existing value 30 . So the printed value be, bash { name: 'Archer', health: 60 } apply() apply() is similar to call() It uses call() underlying js var myMethod = function () {}; // following both statements are similar myMethod(); myMethod.apply(); The only difference between call() and apply() is, in apply() , the parameter is passed through the parenthesis. ```js const wizard = { name: 'Wizard', health: 50, heal(param1, param2) { this.health = this.health + param1 + param2; } }; const archer = { name: 'Archer', health: 30 }; wizard.heal.apply(archer, [10, 20]); console.log(archer); ``` This will print the same value as previous call() method. bash { name: 'Archer', health: 60 } bind() Except the call() and bind() , the bind() does not invoke the method instantly. Instead, it returns a method that can be invoked later. Example ```js const wizard = { name: 'Wizard', health: 50, heal(param1, param2) { this.health = this.health + param1 + param2; } }; const archer = { name: 'Archer', health: 30 }; const archerHeal = wizard.heal.bind(archer, 10, 20); archerHeal(); console.log(archer); ``` This will print the same value as previous call() or apply() method. bash { name: 'Archer', health: 60 } bind() and currying Let's we have a method that take two numbers and return the multiply result. js const multiplyMethod = (num1, num2) => { return num1 * num2; }; Now using function bind, we will create two method from the previous method. Both method will provide only one parameter. One will return multiply with 4 Another will return multiply with 10 ```js let multiplyByTwo = multiplyMethod.bind(this, 4); let multiplyByTen = multiplyMethod.bind(this, 10); console.log(multiplyByTwo(2)); console.log(multiplyByTen(2)); ``` This will return bash 8 20 Using this bind() curring, we can easily bind the method and use the flexibility.","title":"Manipulating the this context"},{"location":"Notes/01 Javascript Foundation/15 this/#benefits","text":"Allow methods and properties of object itself Example const myObject = { name: 'foo', task: function () { return `Do ${this.name} task.`; }, doTask: function () { return `Do ${this.task()}`; } }; myObject.doTask(); This will return Do foo task. Execute same code for multiple objects Example function showMyName() { console.log(this.name); } const foo = { name: 'foo', showMyName }; const bar = { name: 'foo', showMyName }; foo(); bar(); This will return foo bar","title":"Benefits"},{"location":"Notes/01 Javascript Foundation/15 this/#exercise","text":"Let's observe, couple of example Example 01 : const myObj = { name: 'myName', myMethod() { console.log(this); } }; myObj.myMethod(); Here the this is the myObj itself. Example 02 : const myObj = { name: 'myName', myMethod() { return function () { return console.log(this); }; } }; myObj.myMethod()(); Since the return function is not called by the myObj , here the this object is the window . It is using dynamic scope instead of lexical scope . Example 03 : const myObj = { name: 'myName', myMethod() { return () => { return console.log(this); }; } }; myObj.myMethod()(); Since, the arrow method strictly maintain the lexical scope , here the this represent the myObj .","title":"Exercise"},{"location":"Notes/02 Javascript Types/01 Types/","text":"Types Has 7 different types in Javascript number boolean string undefined null (primitive) Symbol() object undefined vs null undefined is the absence of definition In object hoisting we use undefined null is absence of value Types are categorized in 2 sections Primitive (Represents single value) number boolean string undefined null (primitive) Symbol() Non-Primitive object array function Array type typoOf [] returns object In JS the array is interpreted as below js var myArr = ['a', 'b', 'c']; This is same as below syntax. js var myArr = { 0: 'a', 1: 'b', 2: 'c' }; Since both object and array is type of object , we can determine an array by using the Array object and its isArray() method. js console.log(Array.isArray([1, 2, 3])); console.log(Array.isArray({})); Here the first one will print true and the second one false .","title":"01 Types"},{"location":"Notes/02 Javascript Types/01 Types/#types","text":"Has 7 different types in Javascript number boolean string undefined null (primitive) Symbol() object undefined vs null undefined is the absence of definition In object hoisting we use undefined null is absence of value Types are categorized in 2 sections Primitive (Represents single value) number boolean string undefined null (primitive) Symbol() Non-Primitive object array function Array type typoOf [] returns object In JS the array is interpreted as below js var myArr = ['a', 'b', 'c']; This is same as below syntax. js var myArr = { 0: 'a', 1: 'b', 2: 'c' }; Since both object and array is type of object , we can determine an array by using the Array object and its isArray() method. js console.log(Array.isArray([1, 2, 3])); console.log(Array.isArray({})); Here the first one will print true and the second one false .","title":"Types"},{"location":"Notes/02 Javascript Types/02 Pass By Value vs Reference/","text":"Pass By Value vs Reference In Javascript primitive types are immutable and pass by value Primitive types contains single value To change a primitive type, we need to remove it from memory and allocated it to another place For example, to change var a = 5; to a = 10 , we literally move it from memory and create another one. Example : ```js var a = 5; var b = a; b++; console.log(a); console.log(b); ``` Here we will get the output js 5; 6; When we assign a to b , the b create the copy of the value a , which is 5 to it's own memory. Thats why, increasing the b does not impact to the a . On the other hand, objects are Pass by Reference Example : ```js const obj1 = { name: 'John', password: 'myPass' }; const obj2 = obj1; obj2.password = 'changed'; console.log(obj1.password); ``` This will print changed . Since array are object and use reference, this is also applicable to to array. ```js const a = [1, 2, 3]; const b = a; b.push(4); console.log(a); ``` This will print 1, 2, 3, 4 . Avoiding Pass By Reference To avoid array pass by reference, we can use concat spread operator Example : ```js const arr = [1, 2, 3]; const extend = [...arr]; const extend2 = [].concat(arr); extend.push(4); extend2.push(4); console.log(arr); ``` This arr is still [1, 2, 3] . To avoid object pass by reference, we can use, Use spread or assign to avoid shallow copy (aka one layer) Use JSON.parse and JSON.stringify to avoid deep copy Example : ```js const obj = { a: 1, b: 2, c: { d: 3 } }; const clone1 = Object.assign({}, obj); const clone2 = { ...obj }; const deepClone = JSON.parse(JSON.stringify(obj)); obj.b = 500; obj.c.d = 100; console.log(clone1); console.log(clone2); console.log(deepClone); ``` In this case, clone1 and clone2 both being override in the d property. But, in the deepClone object, all the nested object is in separate memory, so not changed. In deep clone using parse and stringify , there will be performance impact.","title":"02 Pass By Value vs Reference"},{"location":"Notes/02 Javascript Types/02 Pass By Value vs Reference/#pass-by-value-vs-reference","text":"In Javascript primitive types are immutable and pass by value Primitive types contains single value To change a primitive type, we need to remove it from memory and allocated it to another place For example, to change var a = 5; to a = 10 , we literally move it from memory and create another one. Example : ```js var a = 5; var b = a; b++; console.log(a); console.log(b); ``` Here we will get the output js 5; 6; When we assign a to b , the b create the copy of the value a , which is 5 to it's own memory. Thats why, increasing the b does not impact to the a . On the other hand, objects are Pass by Reference Example : ```js const obj1 = { name: 'John', password: 'myPass' }; const obj2 = obj1; obj2.password = 'changed'; console.log(obj1.password); ``` This will print changed . Since array are object and use reference, this is also applicable to to array. ```js const a = [1, 2, 3]; const b = a; b.push(4); console.log(a); ``` This will print 1, 2, 3, 4 .","title":"Pass By Value vs Reference"},{"location":"Notes/02 Javascript Types/02 Pass By Value vs Reference/#avoiding-pass-by-reference","text":"To avoid array pass by reference, we can use concat spread operator Example : ```js const arr = [1, 2, 3]; const extend = [...arr]; const extend2 = [].concat(arr); extend.push(4); extend2.push(4); console.log(arr); ``` This arr is still [1, 2, 3] . To avoid object pass by reference, we can use, Use spread or assign to avoid shallow copy (aka one layer) Use JSON.parse and JSON.stringify to avoid deep copy Example : ```js const obj = { a: 1, b: 2, c: { d: 3 } }; const clone1 = Object.assign({}, obj); const clone2 = { ...obj }; const deepClone = JSON.parse(JSON.stringify(obj)); obj.b = 500; obj.c.d = 100; console.log(clone1); console.log(clone2); console.log(deepClone); ``` In this case, clone1 and clone2 both being override in the d property. But, in the deepClone object, all the nested object is in separate memory, so not changed. In deep clone using parse and stringify , there will be performance impact.","title":"Avoiding Pass By Reference"},{"location":"Notes/02 Javascript Types/03 Type Coercion/","text":"Type Coercion When we use == to compare, if the value matches, then JS simply try to map multiple types to a single type. Example console.log(1 == '1'); This is true. This mapping type is Type Coercion . When we use === , it does not use the Type Coercion . console.log(1 === '1'); This is false. Example of JS Coercion Example 1: console.log(1 == '1'); Here the coercion converts the type to string or number , so the results is true. Example 2: if (1) { console.log('1 is True); } Here the coercion converts the type of 1 to true. Example 2: if (0) { console.log('0 is False); } Here the coercion converts the type of 0 to false. Exercise try to guess the outputs. false == ''; false == []; false == {}; '' == 0; '' == []; '' == {}; 0 == []; 0 == {}; 0 == null;","title":"03 Type Coercion"},{"location":"Notes/02 Javascript Types/03 Type Coercion/#type-coercion","text":"When we use == to compare, if the value matches, then JS simply try to map multiple types to a single type. Example console.log(1 == '1'); This is true. This mapping type is Type Coercion . When we use === , it does not use the Type Coercion . console.log(1 === '1'); This is false.","title":"Type Coercion"},{"location":"Notes/02 Javascript Types/03 Type Coercion/#example-of-js-coercion","text":"Example 1: console.log(1 == '1'); Here the coercion converts the type to string or number , so the results is true. Example 2: if (1) { console.log('1 is True); } Here the coercion converts the type of 1 to true. Example 2: if (0) { console.log('0 is False); } Here the coercion converts the type of 0 to false.","title":"Example of JS Coercion"},{"location":"Notes/02 Javascript Types/03 Type Coercion/#exercise","text":"try to guess the outputs. false == ''; false == []; false == {}; '' == 0; '' == []; '' == {}; 0 == []; 0 == {}; 0 == null;","title":"Exercise"},{"location":"Notes/02 Javascript Types/04 JTS/","text":"JTS Dynamic vs Static Type Language Dynamic Typed Language In Dynamic typed language, we do not explicitly say the type of object, like integer, string etc. We can use generic type var , const , let etc. Static Typed Language In static typed language, we have to explicitly say the type of object. Advantages are, self documented. Weekly vs Strongly Typed In JS, 1 + '1'; result 11 . This is weakly typed.","title":"04 JTS"},{"location":"Notes/02 Javascript Types/04 JTS/#jts","text":"","title":"JTS"},{"location":"Notes/02 Javascript Types/04 JTS/#dynamic-vs-static-type-language","text":"Dynamic Typed Language In Dynamic typed language, we do not explicitly say the type of object, like integer, string etc. We can use generic type var , const , let etc. Static Typed Language In static typed language, we have to explicitly say the type of object. Advantages are, self documented.","title":"Dynamic vs Static Type Language"},{"location":"Notes/02 Javascript Types/04 JTS/#weekly-vs-strongly-typed","text":"In JS, 1 + '1'; result 11 . This is weakly typed.","title":"Weekly vs Strongly Typed"},{"location":"Notes/03 Closures And Prototypes/01 Functions Are Objects/","text":"Functions Are Objects Query How come, we can add property to a method? ```js function myMethod() { return 1; } myMethod.foo = bar; console.log(method()); console.log(method.foo); ``` How come we can get the name of the method by method.name ? ```js function myMethod() { return 1; } console.log(myMethod.name); ``` How come we can pass a method with all it's property and data? In method, how come we get the properties like call , apply , bind etc. Discussion We can invoke a method using the following four methods Using old school syntax js function FirstWay() { return 1; } firstWay(); Using an ES6 , in this case, the this context is the object context ```js const obj = { function secondWay() { return 2; } } obj.secondWay(); ``` Using call method ```js const thirdWay() { return 3; } thirdWay(); ``` Using Function constructor ```js const fourthWay = new Function('return 4'); fourthWay(); ``` We can also use parameter in the Function constructor. ```js const fourthWay = new Function('num', 'return num'); fourthWay(4); ``` We can assign an object like property in the function , example ```js function test() { return 1; } test.foo = 'bar'; console.log(test()); console.log(test.foo); console.log(test.name); ``` Here we will get output bash 1 bar test Here we can add a property in the function, just like an object. Internally, when we define a object in Javascript , it interpret the Test function , we defined earlier, something like the following object js const specialFunctionMethod = { name: 'test', foo: 'bar', (): 'return 1' } Whenever we create a method, internally a object is being created with the following properties code (We can invoke using () ) name (optional, because the arrow method does not have a name ) properties call apply bind Final Thought Functions are just objects in Javascript We can pass them around like objects, like containing data Besides just doing things and perform actions, Javascript function are stored as data","title":"01 Functions Are Objects"},{"location":"Notes/03 Closures And Prototypes/01 Functions Are Objects/#functions-are-objects","text":"Query How come, we can add property to a method? ```js function myMethod() { return 1; } myMethod.foo = bar; console.log(method()); console.log(method.foo); ``` How come we can get the name of the method by method.name ? ```js function myMethod() { return 1; } console.log(myMethod.name); ``` How come we can pass a method with all it's property and data? In method, how come we get the properties like call , apply , bind etc. Discussion We can invoke a method using the following four methods Using old school syntax js function FirstWay() { return 1; } firstWay(); Using an ES6 , in this case, the this context is the object context ```js const obj = { function secondWay() { return 2; } } obj.secondWay(); ``` Using call method ```js const thirdWay() { return 3; } thirdWay(); ``` Using Function constructor ```js const fourthWay = new Function('return 4'); fourthWay(); ``` We can also use parameter in the Function constructor. ```js const fourthWay = new Function('num', 'return num'); fourthWay(4); ``` We can assign an object like property in the function , example ```js function test() { return 1; } test.foo = 'bar'; console.log(test()); console.log(test.foo); console.log(test.name); ``` Here we will get output bash 1 bar test Here we can add a property in the function, just like an object. Internally, when we define a object in Javascript , it interpret the Test function , we defined earlier, something like the following object js const specialFunctionMethod = { name: 'test', foo: 'bar', (): 'return 1' } Whenever we create a method, internally a object is being created with the following properties code (We can invoke using () ) name (optional, because the arrow method does not have a name ) properties call apply bind","title":"Functions Are Objects"},{"location":"Notes/03 Closures And Prototypes/01 Functions Are Objects/#final-thought","text":"Functions are just objects in Javascript We can pass them around like objects, like containing data Besides just doing things and perform actions, Javascript function are stored as data","title":"Final Thought"},{"location":"Notes/03 Closures And Prototypes/02 Function As First Class Citizen/","text":"Function As First Class Citizen For the following 3 properties, functions are considered First Class Citizen in Javascript We can assign function to variables ```js const myVar = function () { return 1; }; console.log(myVar()); ``` We can pass function as arguments ```js function one() { console.log(1); } function two(fn) { fn(); } two(one); two(function () { console.log('2'); }); ``` We can also return function ```js function one() { return function two() { console.log(2); }; } one()(); ```","title":"02 Function As First Class Citizen"},{"location":"Notes/03 Closures And Prototypes/02 Function As First Class Citizen/#function-as-first-class-citizen","text":"For the following 3 properties, functions are considered First Class Citizen in Javascript We can assign function to variables ```js const myVar = function () { return 1; }; console.log(myVar()); ``` We can pass function as arguments ```js function one() { console.log(1); } function two(fn) { fn(); } two(one); two(function () { console.log('2'); }); ``` We can also return function ```js function one() { return function two() { console.log(2); }; } one()(); ```","title":"Function As First Class Citizen"},{"location":"Notes/03 Closures And Prototypes/03 Higher Order Function/","text":"Higher Order Function Accepts function as parameter Allow codes make more generic Allow to pass methods not just data, but also method Example 01 function authenticate(data, authStrategy) { // do the auth mechanism return giveAccessTo(data.name); } function letPersonAuthenticate(data, fn) { if (data.level === 'admin') { fn(data, 'AdminStrategy'); } else if (data.level === 'user') { fn(data, 'UserStrategy'); } } letPersonAuthenticate({ name: 'Tim', level: 'user' }, authenticate); letPersonAuthenticate({ name: 'Sally', level: 'admin' }, authenticate); Example 02 const multiplyBy = (value1, value2) => { return value1 * value2; }; const multiplyByTwo = val => { return multiplyBy(val, 2); }; const multiplyByFour = val => { return multiplyBy(val, 4); }; Example 03 const multiplyBy = function (value1) { return function (value2) { return value1 * value2; }; }; const multiplyByTwo = multiplyBy(2); const multiplyByFour = multiplyBy(4); multiplyByTwo(10); multiplyByTwo(20); Example 04 Simplify the previous example. const multiplyBy = val1 => val2 => val * val2; const multiplyByTwo = multiplyBy(2); const multiplyByFour = multiplyBy(4); multiplyByTwo(10); multiplyByTwo(20);","title":"03 Higher Order Function"},{"location":"Notes/03 Closures And Prototypes/03 Higher Order Function/#higher-order-function","text":"Accepts function as parameter Allow codes make more generic Allow to pass methods not just data, but also method Example 01 function authenticate(data, authStrategy) { // do the auth mechanism return giveAccessTo(data.name); } function letPersonAuthenticate(data, fn) { if (data.level === 'admin') { fn(data, 'AdminStrategy'); } else if (data.level === 'user') { fn(data, 'UserStrategy'); } } letPersonAuthenticate({ name: 'Tim', level: 'user' }, authenticate); letPersonAuthenticate({ name: 'Sally', level: 'admin' }, authenticate); Example 02 const multiplyBy = (value1, value2) => { return value1 * value2; }; const multiplyByTwo = val => { return multiplyBy(val, 2); }; const multiplyByFour = val => { return multiplyBy(val, 4); }; Example 03 const multiplyBy = function (value1) { return function (value2) { return value1 * value2; }; }; const multiplyByTwo = multiplyBy(2); const multiplyByFour = multiplyBy(4); multiplyByTwo(10); multiplyByTwo(20); Example 04 Simplify the previous example. const multiplyBy = val1 => val2 => val * val2; const multiplyByTwo = multiplyBy(2); const multiplyByFour = multiplyBy(4); multiplyByTwo(10); multiplyByTwo(20);","title":"Higher Order Function"},{"location":"Notes/03 Closures And Prototypes/04 Closures/","text":"Closures Closures is the combination of function and lexical scope Function Since they are first class citizen in JS, We can pass function as data We can also return function as data Lexical Scope Means JS engine knows where the code is written before we even run the code, what variable each function has accessed to. Closure allows a method to access variables of methods, even though the method left the stack Example 01: Storing Local Properties function a() { const grandpa = \"Grandpa\"; return function b() { const father = \"Father\"; return function c() { const son = \"Son\"; return `${grandpa} > ${father} > ${son}`; }; }; } const one = a(); // 10 years later... one()(); This will return Grandpa > Father > Son Here after we invoke the a() the a() method should be popped out from the scope . Also its property grandpa should be popped out from the stack. Since the reference of the grandpa is used in the c() , the closure will store these. So when garbage collector came to removed the this grandpa will not be removed from the memory. Example 02: Storing Local Properties function a() { const grandpa = \"Grandpa\"; const someRandomVariable = \"random value\"; return function b() { const father = \"Father\"; return function c() { const son = \"Son\"; return `${grandpa} > ${father} > ${son}`; }; }; } const one = a(); one()(); This will return Grandpa > Father > Son Since the variable someRandomVariable is not referenced to any of the method, it will be removed by the garbage collector . Example 03: Storing Reference Parameters const hoc = (num1) => (num2) => num1 * num2; const multiplyByTen = hoc(10); multiplyByTen(5); Here's another example of closure is the first parameter 10 is being preserved from the garbage collector . So we can use even though the first arrow method hoc() is being removed from the lexical scope Example 03: With Event Loop function myMethod() { const myVar = \"Hello from closures\"; setTimeout(function () { console.log(myVar); }, 4000); } myMethod(); This will print Hello from closures Here we pass the setTimeout part to the web-api and start a timer of 4 seconds . When 4 seconds time is over code is return to the call-back queue , and wait for the empty call-stack . When it goes to the call stack, the myMethod should be removed from the stack. But the myVar will be kept in the closure , as it is referenced in the setTimeout method. Example 03: Ignore Hoisting function myMethod() { setTimeout(function () { console.log(myVar); }, 4000); const myVar = \"Hello from closures\"; } myMethod(); This will also print Hello from closures Since const does not hoist, the myVar should be a reference error . But closure ignore the hoisting and print the Hello from closures . Because by the time (after 4 seconds), we call the method, the variable should be persisted in the closure. Advantages Example: Memory Efficiency Lets consider a method, that creates a large array. It returns the array elements by the index we pass. function heavyDuty(index) { const bigArray = new Array(10000).fill(\"element\"); return bigArray[index]; } heavyDuty(10); heavyDuty(5000); Here every time we invoke the method heavyDuty method, a new array is being created with 10000 items and return the element of the desired index. In this case repeatedly after each call we have to generate an array of 10000 elements. We can cache the array by the following way using closures. function heavyDuty(index) { const bigArray = new Array(10000).fill(\"element\"); return function (index) { return bigArray[index]; }; } const getElement = heavyDuty(); getElement(10); getElement(5000); In this way, we do not pollute the global scope. We create the array once and invoke the element by index multiple time. Example: Memory Encapsulation Let's consider a method. const makeNuclearButton = () => { let timeWithoutDestruction = 0; const peaceTime = () => timeWithoutDestruction++; const totalPeaceTime = () => timeWithoutDestruction; const launch = () => { timeWithoutDestruction = -1; return \"Booooom!!!!\"; }; setInterval(peaceTime, 1000); return { launch, totalPeaceTime, }; }; const noooo = makeNuclearButton(); noooo.totalPeaceTime(); Here when we make the object of makeNuclearButton , until we invoke launch method, the peaceTime is increasing. The moment we invoke the launch method, using noooo.launch() the peaceTime become 0 . Now our concern is not had over the launch method to everyone. We simmply remove the launch method from the return object. const makeNuclearButton = () => { let timeWithoutDestruction = 0; const peaceTime = () => timeWithoutDestruction++; const totalPeaceTime = () => timeWithoutDestruction; const launch = () => { timeWithoutDestruction = -1; return \"Booooom!!!!\"; }; setInterval(peaceTime, 1000); return { totalPeaceTime, }; }; const noooo = makeNuclearButton(); noooo.totalPeaceTime(); This is a philosophy of encapsulation or least privilege . Exercise Lets consider a function initialize() and it set some global value. The important thing is it should be called only one time. let globalKey; function initialize() { globalKey = \"value\"; console.log(\"Global key is set\"); } initialize(); initialize(); initialize(); Here the function is being invoked 3 times. With closure, we need to call it once. let globalKey; function initialize() { let isCalled = false; return () => { if (isCalled) { return; } isCalled = true; globalKey = \"value\"; console.log(\"Global key is set\"); }; } const startOnce = initialize(); startOnce(); startOnce(); startOnce(); Now, this will be only called once. Another approach to solve the problem can be, updating the function reference after being initialize at the first time. let globalKey; function initialize() { globalKey = \"value\"; console.log(\"Global key is set\"); initialize = () => { console.log(\"Aboarting! already set the value\"); }; } initialize(); initialize(); Using IIFE, let globalKey; const initialize = (() => { let called = 0; return () => { if (called) { console.log(\"Already Set\"); return; } called = 1; globalKey = \"Global Value\"; console.log(\"Set the value\"); }; })(); initialize(); initialize(); initialize(); Exercise In this case, const array = [1, 2, 3, 4]; function traverse() { for (var i = 0; i < array.length; i++) { setTimeout(function () { console.log(i); }, 1000); } } traverse(); In this case, the var is used the hoisting and get the laterst index. using let instead of var can resolve the issue. const array = [1, 2, 3, 4]; function traverse() { for (let i = 0; i < array.length; i++) { setTimeout(function () { console.log(i); }, 1000); } } traverse(); Using IIFE and closure, const array = [1, 2, 3, 4]; function traverse() { for (var i = 0; i < array.length; i++) { (function (val) { setTimeout(function () { console.log(val); }, 1000); })(i); } } traverse();","title":"04 Closures"},{"location":"Notes/03 Closures And Prototypes/04 Closures/#closures","text":"Closures is the combination of function and lexical scope Function Since they are first class citizen in JS, We can pass function as data We can also return function as data Lexical Scope Means JS engine knows where the code is written before we even run the code, what variable each function has accessed to. Closure allows a method to access variables of methods, even though the method left the stack Example 01: Storing Local Properties function a() { const grandpa = \"Grandpa\"; return function b() { const father = \"Father\"; return function c() { const son = \"Son\"; return `${grandpa} > ${father} > ${son}`; }; }; } const one = a(); // 10 years later... one()(); This will return Grandpa > Father > Son Here after we invoke the a() the a() method should be popped out from the scope . Also its property grandpa should be popped out from the stack. Since the reference of the grandpa is used in the c() , the closure will store these. So when garbage collector came to removed the this grandpa will not be removed from the memory. Example 02: Storing Local Properties function a() { const grandpa = \"Grandpa\"; const someRandomVariable = \"random value\"; return function b() { const father = \"Father\"; return function c() { const son = \"Son\"; return `${grandpa} > ${father} > ${son}`; }; }; } const one = a(); one()(); This will return Grandpa > Father > Son Since the variable someRandomVariable is not referenced to any of the method, it will be removed by the garbage collector . Example 03: Storing Reference Parameters const hoc = (num1) => (num2) => num1 * num2; const multiplyByTen = hoc(10); multiplyByTen(5); Here's another example of closure is the first parameter 10 is being preserved from the garbage collector . So we can use even though the first arrow method hoc() is being removed from the lexical scope Example 03: With Event Loop function myMethod() { const myVar = \"Hello from closures\"; setTimeout(function () { console.log(myVar); }, 4000); } myMethod(); This will print Hello from closures Here we pass the setTimeout part to the web-api and start a timer of 4 seconds . When 4 seconds time is over code is return to the call-back queue , and wait for the empty call-stack . When it goes to the call stack, the myMethod should be removed from the stack. But the myVar will be kept in the closure , as it is referenced in the setTimeout method. Example 03: Ignore Hoisting function myMethod() { setTimeout(function () { console.log(myVar); }, 4000); const myVar = \"Hello from closures\"; } myMethod(); This will also print Hello from closures Since const does not hoist, the myVar should be a reference error . But closure ignore the hoisting and print the Hello from closures . Because by the time (after 4 seconds), we call the method, the variable should be persisted in the closure.","title":"Closures"},{"location":"Notes/03 Closures And Prototypes/04 Closures/#advantages","text":"Example: Memory Efficiency Lets consider a method, that creates a large array. It returns the array elements by the index we pass. function heavyDuty(index) { const bigArray = new Array(10000).fill(\"element\"); return bigArray[index]; } heavyDuty(10); heavyDuty(5000); Here every time we invoke the method heavyDuty method, a new array is being created with 10000 items and return the element of the desired index. In this case repeatedly after each call we have to generate an array of 10000 elements. We can cache the array by the following way using closures. function heavyDuty(index) { const bigArray = new Array(10000).fill(\"element\"); return function (index) { return bigArray[index]; }; } const getElement = heavyDuty(); getElement(10); getElement(5000); In this way, we do not pollute the global scope. We create the array once and invoke the element by index multiple time. Example: Memory Encapsulation Let's consider a method. const makeNuclearButton = () => { let timeWithoutDestruction = 0; const peaceTime = () => timeWithoutDestruction++; const totalPeaceTime = () => timeWithoutDestruction; const launch = () => { timeWithoutDestruction = -1; return \"Booooom!!!!\"; }; setInterval(peaceTime, 1000); return { launch, totalPeaceTime, }; }; const noooo = makeNuclearButton(); noooo.totalPeaceTime(); Here when we make the object of makeNuclearButton , until we invoke launch method, the peaceTime is increasing. The moment we invoke the launch method, using noooo.launch() the peaceTime become 0 . Now our concern is not had over the launch method to everyone. We simmply remove the launch method from the return object. const makeNuclearButton = () => { let timeWithoutDestruction = 0; const peaceTime = () => timeWithoutDestruction++; const totalPeaceTime = () => timeWithoutDestruction; const launch = () => { timeWithoutDestruction = -1; return \"Booooom!!!!\"; }; setInterval(peaceTime, 1000); return { totalPeaceTime, }; }; const noooo = makeNuclearButton(); noooo.totalPeaceTime(); This is a philosophy of encapsulation or least privilege . Exercise Lets consider a function initialize() and it set some global value. The important thing is it should be called only one time. let globalKey; function initialize() { globalKey = \"value\"; console.log(\"Global key is set\"); } initialize(); initialize(); initialize(); Here the function is being invoked 3 times. With closure, we need to call it once. let globalKey; function initialize() { let isCalled = false; return () => { if (isCalled) { return; } isCalled = true; globalKey = \"value\"; console.log(\"Global key is set\"); }; } const startOnce = initialize(); startOnce(); startOnce(); startOnce(); Now, this will be only called once. Another approach to solve the problem can be, updating the function reference after being initialize at the first time. let globalKey; function initialize() { globalKey = \"value\"; console.log(\"Global key is set\"); initialize = () => { console.log(\"Aboarting! already set the value\"); }; } initialize(); initialize(); Using IIFE, let globalKey; const initialize = (() => { let called = 0; return () => { if (called) { console.log(\"Already Set\"); return; } called = 1; globalKey = \"Global Value\"; console.log(\"Set the value\"); }; })(); initialize(); initialize(); initialize(); Exercise In this case, const array = [1, 2, 3, 4]; function traverse() { for (var i = 0; i < array.length; i++) { setTimeout(function () { console.log(i); }, 1000); } } traverse(); In this case, the var is used the hoisting and get the laterst index. using let instead of var can resolve the issue. const array = [1, 2, 3, 4]; function traverse() { for (let i = 0; i < array.length; i++) { setTimeout(function () { console.log(i); }, 1000); } } traverse(); Using IIFE and closure, const array = [1, 2, 3, 4]; function traverse() { for (var i = 0; i < array.length; i++) { (function (val) { setTimeout(function () { console.log(val); }, 1000); })(i); } } traverse();","title":"Advantages"},{"location":"Notes/03 Closures And Prototypes/05 Prototypal Inheritance 01/","text":"Prototypal Inheritance 01 Javascript uses prototypal inheritance (Java, Python like language use classical inheritance). Inheritance means, an object getting access of another object methods and properties. It helps Avoid repeating functionalities Making innovative programming paradigms In Javascript, class keyword is a syntactic sugar . Internally it uses the prototypal inheritance . Both array and function are objects in Javascript. So any object , array and function can use the property of the parent prototyped chain object properties and methods. Example 01: Array Prototype Chain const array = []; Here we created an array. This array object is created by the constructor of a object. We can access theses constructor anr other array methods like concat , fill , find , push , pop etc using the following, console.log(array.__proto__); Using prototype chain we can access the base object, using the following, console.log(array.__proto__.__proto__); From this base object, we can access the base object properties and methods like, constructor , hasOwnProperty , toString , valueOf etc. Now we can use the base object method using the prototype chain. For example to use the toString method from base object, we can write array.toString(); Since our array is empty, it will return empty string. Example 02: Function Prototype Chain Let's create a method function a() {} Using prototype chain, we can observe the native function . The native function is the one, created all other functions . console.log(a.__proto__); Using the prototype chain , if we go one step closer, we will find the base object . console.log(a.__proto__.__proto__); Example 02: Object Prototype Chain Now let's declare a object const obj = {}; If we check the prototype chain, we will found the base object . console.log(obj.__proto__);","title":"05 Prototypal Inheritance 01"},{"location":"Notes/03 Closures And Prototypes/05 Prototypal Inheritance 01/#prototypal-inheritance-01","text":"Javascript uses prototypal inheritance (Java, Python like language use classical inheritance). Inheritance means, an object getting access of another object methods and properties. It helps Avoid repeating functionalities Making innovative programming paradigms In Javascript, class keyword is a syntactic sugar . Internally it uses the prototypal inheritance . Both array and function are objects in Javascript. So any object , array and function can use the property of the parent prototyped chain object properties and methods. Example 01: Array Prototype Chain const array = []; Here we created an array. This array object is created by the constructor of a object. We can access theses constructor anr other array methods like concat , fill , find , push , pop etc using the following, console.log(array.__proto__); Using prototype chain we can access the base object, using the following, console.log(array.__proto__.__proto__); From this base object, we can access the base object properties and methods like, constructor , hasOwnProperty , toString , valueOf etc. Now we can use the base object method using the prototype chain. For example to use the toString method from base object, we can write array.toString(); Since our array is empty, it will return empty string. Example 02: Function Prototype Chain Let's create a method function a() {} Using prototype chain, we can observe the native function . The native function is the one, created all other functions . console.log(a.__proto__); Using the prototype chain , if we go one step closer, we will find the base object . console.log(a.__proto__.__proto__); Example 02: Object Prototype Chain Now let's declare a object const obj = {}; If we check the prototype chain, we will found the base object . console.log(obj.__proto__);","title":"Prototypal Inheritance 01"},{"location":"Notes/03 Closures And Prototypes/06 Prototypal Inheritance 02/","text":"Prototypal Inheritance 02 Lets create two character, const dragon = { name: 'Tanya', fire: true, fight() { return 5; }, sing() { return `I am ${this.name}, the breather of fire`; } }; const lizard = { name: 'Kiki', fight() { return 1; } }; Now we want to use the sing() method of for lizard . But lizard does not have the sing() method. In this case we have to use the dragon object sing() method. To use the dragon objects method, we can use the bind property. const singLizard = dragon.sing.bind(lizard); singLizard(); This will give the output I am Kiki, the breather of fire Now if we update the dragon objects sing() method, that, to sing, the fire property is will be required, then the new dragon object will be, const dragon = { name: 'Tanya', fire: true, fight() { return 5; }, sing() { if (fire) { return `I am ${this.name}, the breather of fire`; } } }; In this case, if we call singLizard() the sing method will not return the statement. To return the statement, we have to bind the fire property for the lizard also from the dragon object. To resolve this issue, instead of binding, we can use the prototype chain . lizard.__proto__ = dragon; lizard.sing(); In this case, when the sing() method will not be found in the lizard object, it will check the prototype chain and execute the sing() method from there. After using the prototype chain , if we invoke the fight() method for the lizard object, lizard.__proto__ = dragon; lizard.fight(); This will return 1 Because, this fight method is already exist in the lizard object. So it will not go to the prototype-chain for fight() method of dragon object. We can if the dragon is a prototype of lizard by the following, dragon.isPrototypeOf(lizard); This will be true . And this isPrototypeOf came from the base object , also using the prototype chain .","title":"06 Prototypal Inheritance 02"},{"location":"Notes/03 Closures And Prototypes/06 Prototypal Inheritance 02/#prototypal-inheritance-02","text":"Lets create two character, const dragon = { name: 'Tanya', fire: true, fight() { return 5; }, sing() { return `I am ${this.name}, the breather of fire`; } }; const lizard = { name: 'Kiki', fight() { return 1; } }; Now we want to use the sing() method of for lizard . But lizard does not have the sing() method. In this case we have to use the dragon object sing() method. To use the dragon objects method, we can use the bind property. const singLizard = dragon.sing.bind(lizard); singLizard(); This will give the output I am Kiki, the breather of fire Now if we update the dragon objects sing() method, that, to sing, the fire property is will be required, then the new dragon object will be, const dragon = { name: 'Tanya', fire: true, fight() { return 5; }, sing() { if (fire) { return `I am ${this.name}, the breather of fire`; } } }; In this case, if we call singLizard() the sing method will not return the statement. To return the statement, we have to bind the fire property for the lizard also from the dragon object. To resolve this issue, instead of binding, we can use the prototype chain . lizard.__proto__ = dragon; lizard.sing(); In this case, when the sing() method will not be found in the lizard object, it will check the prototype chain and execute the sing() method from there. After using the prototype chain , if we invoke the fight() method for the lizard object, lizard.__proto__ = dragon; lizard.fight(); This will return 1 Because, this fight method is already exist in the lizard object. So it will not go to the prototype-chain for fight() method of dragon object. We can if the dragon is a prototype of lizard by the following, dragon.isPrototypeOf(lizard); This will be true . And this isPrototypeOf came from the base object , also using the prototype chain .","title":"Prototypal Inheritance 02"},{"location":"Notes/03 Closures And Prototypes/07 Prototypal Inheritance 03/","text":"Prototypal Inheritance 03 Prototype chain does not copy the properties, it just use the properties and methods. Example const dragon = { name: 'Tanya', fire: true, fight() { return 5; }, sing() { return `I am ${this.name}, the breather of fire`; } }; const lizard = { name: 'Kiki', fight() { return 1; } }; lizard.__proto__ = dragon; for (let prop in lizard) { console.log( `Is ${prop} lizards own property: ${lizard.hasOwnProperty(prop)}` ); } This will give us output Is name lizards own property: true Is fight lizards own property: true Is fire lizards own property: false Is sing lizards own property: false So we can see, only name and fight are the lizard own property. Both fire and sing properties are come from the prototype-chain . Since it is not copy the properties, this is helpful. For example if we use sing method of dragon object in multiple places, we can use the one single instance. We are not repeating ourselves and saving memory. Prototype chain for a function Let's create a function function myMethod() {} We know function are special type of object in Javascript . So the following statement should return true . myMethod.hasOwnProperty(call); But this will return false . Because, these call , bind , apply methods are appeared in a method through the prototype-chain . The __proto__ of the myMethod linked to the native base function prototype object. That base function prototype object contains all the following, call apply bind __proto__ , this point to the base object of Javascript Many more ... myMethod.___proto__.hasOwnProperty('call'); This will return true. And this __proto__ of the base function prototype chain to the base object prototype property. Base object __proto__ of the prototype property point to the null . Prototype Chian for Function let's define an array. const myArr = []; We know the javascript array has property called map . Let's check myArr.hasOwnProperty('map'); This will return false . Because the map come through the prototype-chain . When we create an array, it is created by the Array object. Using prototype chain we can access the Array and check the map property existence. myArr.__proto__.hasOwnProperty('map'); This should return true .","title":"07 Prototypal Inheritance 03"},{"location":"Notes/03 Closures And Prototypes/07 Prototypal Inheritance 03/#prototypal-inheritance-03","text":"","title":"Prototypal Inheritance 03"},{"location":"Notes/03 Closures And Prototypes/07 Prototypal Inheritance 03/#prototype-chain-does-not-copy-the-properties-it-just-use-the-properties-and-methods","text":"Example const dragon = { name: 'Tanya', fire: true, fight() { return 5; }, sing() { return `I am ${this.name}, the breather of fire`; } }; const lizard = { name: 'Kiki', fight() { return 1; } }; lizard.__proto__ = dragon; for (let prop in lizard) { console.log( `Is ${prop} lizards own property: ${lizard.hasOwnProperty(prop)}` ); } This will give us output Is name lizards own property: true Is fight lizards own property: true Is fire lizards own property: false Is sing lizards own property: false So we can see, only name and fight are the lizard own property. Both fire and sing properties are come from the prototype-chain . Since it is not copy the properties, this is helpful. For example if we use sing method of dragon object in multiple places, we can use the one single instance. We are not repeating ourselves and saving memory.","title":"Prototype chain does not copy the properties, it just use the properties and methods."},{"location":"Notes/03 Closures And Prototypes/07 Prototypal Inheritance 03/#prototype-chain-for-a-function","text":"Let's create a function function myMethod() {} We know function are special type of object in Javascript . So the following statement should return true . myMethod.hasOwnProperty(call); But this will return false . Because, these call , bind , apply methods are appeared in a method through the prototype-chain . The __proto__ of the myMethod linked to the native base function prototype object. That base function prototype object contains all the following, call apply bind __proto__ , this point to the base object of Javascript Many more ... myMethod.___proto__.hasOwnProperty('call'); This will return true. And this __proto__ of the base function prototype chain to the base object prototype property. Base object __proto__ of the prototype property point to the null .","title":"Prototype chain for a function"},{"location":"Notes/03 Closures And Prototypes/07 Prototypal Inheritance 03/#prototype-chian-for-function","text":"let's define an array. const myArr = []; We know the javascript array has property called map . Let's check myArr.hasOwnProperty('map'); This will return false . Because the map come through the prototype-chain . When we create an array, it is created by the Array object. Using prototype chain we can access the Array and check the map property existence. myArr.__proto__.hasOwnProperty('map'); This should return true .","title":"Prototype Chian for Function"},{"location":"Notes/03 Closures And Prototypes/08 Prototypal Inheritance 04/","text":"Creating Our Own Prototype We should never use the keyword __proto__ , because that impact on execution performance. The keyword is named intentionally with four underscore, so no one accidentally use it. To use the prototype-chin we can use the Object.create() function. const human = { mortal: true }; const socrates = Object.create(human); socrates.age = 80; console.log(`Age of socrates: ${socrates.age}`); console.log( `Is human a prototype of socrates: ${human.isPrototypeOf(socrates)}` ); This will give us the following output, Age of socrates: 80 Is human a prototype of socrates: true","title":"08 Prototypal Inheritance 04"},{"location":"Notes/03 Closures And Prototypes/08 Prototypal Inheritance 04/#creating-our-own-prototype","text":"We should never use the keyword __proto__ , because that impact on execution performance. The keyword is named intentionally with four underscore, so no one accidentally use it. To use the prototype-chin we can use the Object.create() function. const human = { mortal: true }; const socrates = Object.create(human); socrates.age = 80; console.log(`Age of socrates: ${socrates.age}`); console.log( `Is human a prototype of socrates: ${human.isPrototypeOf(socrates)}` ); This will give us the following output, Age of socrates: 80 Is human a prototype of socrates: true","title":"Creating Our Own Prototype"},{"location":"Notes/03 Closures And Prototypes/09 Prototypal Inheritance 05/","text":"Prototypal Inheritance 05 Only function has prototype object Let's create an object and a function and check if there is prototype object. const obj = {}; function myFunc() {} console.log(obj.hasOwnProperty('prototype')); console.log(myFunc.hasOwnProperty('prototype')); This will return false true Now we know the base object of Javascript Object has a property property . Object.hasOwnProperty('prototype'); This will return true . Actually the Object of the javascript is a function not an object.","title":"09 Prototypal Inheritance 05"},{"location":"Notes/03 Closures And Prototypes/09 Prototypal Inheritance 05/#prototypal-inheritance-05","text":"","title":"Prototypal Inheritance 05"},{"location":"Notes/03 Closures And Prototypes/09 Prototypal Inheritance 05/#only-function-has-prototype-object","text":"Let's create an object and a function and check if there is prototype object. const obj = {}; function myFunc() {} console.log(obj.hasOwnProperty('prototype')); console.log(myFunc.hasOwnProperty('prototype')); This will return false true Now we know the base object of Javascript Object has a property property . Object.hasOwnProperty('prototype'); This will return true . Actually the Object of the javascript is a function not an object.","title":"Only function has prototype object"},{"location":"Notes/03 Closures And Prototypes/10 Prototypal Inheritance Exercise/","text":"Prototypal Inheritance Exercise Add a new functionality in Date object Let's add a new function named lastYear of the Date object, that will return the 1 year earlier than current year. Date.prototype.lastYear = function () { return this.getFullYear() - 1; }; new Date('1900-10-10').lastYear(); Here we use function keyword instead of arrow method to use dynamic-scope instead of lexical-scope . When using function keyword, the this context is the new Date . But with arrow method the this context is the arrow method itself, given below, () => { return this.getFullYear() - 1; }; Manipulate the map functionality of Array Array.prototype.map = function (args) { const newArray = []; this.forEach(val => newArray.push(`manipulated ${val}`)); return newArray; }; console.log([1, 2, 3].map()); This will give us output [ 'manipulated 1', 'manipulated 2', 'manipulated 3' ] Creating own bind method using the apply or call Function.prototype.bind = function (whoIsCallingMe) { const self = this; return function () { return self.apply(whoIsCallingMe, arguments); }; };","title":"10 Prototypal Inheritance Exercise"},{"location":"Notes/03 Closures And Prototypes/10 Prototypal Inheritance Exercise/#prototypal-inheritance-exercise","text":"","title":"Prototypal Inheritance Exercise"},{"location":"Notes/03 Closures And Prototypes/10 Prototypal Inheritance Exercise/#add-a-new-functionality-in-date-object","text":"Let's add a new function named lastYear of the Date object, that will return the 1 year earlier than current year. Date.prototype.lastYear = function () { return this.getFullYear() - 1; }; new Date('1900-10-10').lastYear(); Here we use function keyword instead of arrow method to use dynamic-scope instead of lexical-scope . When using function keyword, the this context is the new Date . But with arrow method the this context is the arrow method itself, given below, () => { return this.getFullYear() - 1; };","title":"Add a new functionality in Date object"},{"location":"Notes/03 Closures And Prototypes/10 Prototypal Inheritance Exercise/#manipulate-the-map-functionality-of-array","text":"Array.prototype.map = function (args) { const newArray = []; this.forEach(val => newArray.push(`manipulated ${val}`)); return newArray; }; console.log([1, 2, 3].map()); This will give us output [ 'manipulated 1', 'manipulated 2', 'manipulated 3' ]","title":"Manipulate the map functionality of Array"},{"location":"Notes/03 Closures And Prototypes/10 Prototypal Inheritance Exercise/#creating-own-bind-method-using-the-apply-or-call","text":"Function.prototype.bind = function (whoIsCallingMe) { const self = this; return function () { return self.apply(whoIsCallingMe, arguments); }; };","title":"Creating own bind method using the apply or call"},{"location":"Notes/04 OOP/01 OOP VS FP/","text":"OOP vs FP OOP takes data and all its behavior and put it in an object. FP believe data is separated from behavior and handle isolated way.","title":"01 OOP VS FP"},{"location":"Notes/04 OOP/01 OOP VS FP/#oop-vs-fp","text":"OOP takes data and all its behavior and put it in an object. FP believe data is separated from behavior and handle isolated way.","title":"OOP vs FP"},{"location":"Notes/04 OOP/02 Factory Function/","text":"Factory Function Consider avengers with their name and power. When we allocate Thor in a object, const avenger1 = { name: 'Thor', weapon: 'Hammer', attack() { console.log(`${this.name} attack with ${this.weapon}`); } }; avenger1.attack(); // Thor attack with Hammer And when we allocate Doctor Strange , const avenger2 = { name: 'Doctor Strange', weapon: 'Magic', attack() { console.log(`${this.name} attack with ${this.weapon}`); } }; avenger2.attack(); // Doctor Strange attack with Magic In this case we can make use of Factory Function and reduce declaring both object. Our factory function will be const avenger = (name, weapon) => { return { name, weapon, attack() { console.log(`${this.name} attack with ${this.weapon}`); } }; }; const thor = avenger('Thor', 'Hammer'); thor.attack(); // Thor attack with Hammer const doctorStranger = avenger('Doctor Stranger', 'Magic'); doctorStranger.attack(); // Doctor Strange attack with Magic With factory function, we can simplify the logic and reuse the logic. The only trade-offs we can find is, repeat the attack method. When we have many avengers, they will have the separate name and weapon. It is okay to persist them in memory. Since, the attack method is always same, keeping it with every avengers is a waste of memory. Since the Thor or Doctor Stranger are invoking the same attack method, we need to make use of prototype to reduce the method define with each object.","title":"02 Factory Function"},{"location":"Notes/04 OOP/02 Factory Function/#factory-function","text":"Consider avengers with their name and power. When we allocate Thor in a object, const avenger1 = { name: 'Thor', weapon: 'Hammer', attack() { console.log(`${this.name} attack with ${this.weapon}`); } }; avenger1.attack(); // Thor attack with Hammer And when we allocate Doctor Strange , const avenger2 = { name: 'Doctor Strange', weapon: 'Magic', attack() { console.log(`${this.name} attack with ${this.weapon}`); } }; avenger2.attack(); // Doctor Strange attack with Magic In this case we can make use of Factory Function and reduce declaring both object. Our factory function will be const avenger = (name, weapon) => { return { name, weapon, attack() { console.log(`${this.name} attack with ${this.weapon}`); } }; }; const thor = avenger('Thor', 'Hammer'); thor.attack(); // Thor attack with Hammer const doctorStranger = avenger('Doctor Stranger', 'Magic'); doctorStranger.attack(); // Doctor Strange attack with Magic With factory function, we can simplify the logic and reuse the logic. The only trade-offs we can find is, repeat the attack method. When we have many avengers, they will have the separate name and weapon. It is okay to persist them in memory. Since, the attack method is always same, keeping it with every avengers is a waste of memory. Since the Thor or Doctor Stranger are invoking the same attack method, we need to make use of prototype to reduce the method define with each object.","title":"Factory Function"}]}